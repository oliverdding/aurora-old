+++
title="可扩展布隆过滤器"
description="基于布隆过滤器的一个变种实现的可扩展布隆过滤器，无需使用前预估存储量"
date=2022-02-15T14:00:16+08:00

[taxonomies]
categories = ["ProbabilisticDataStructure"]
tags = ["data structure"]

[extra]
toc = true
comments = true
+++

## 介绍

在上篇博文[基础布隆过滤器](/posts/bloom-filter-1/)中介绍了基础的bloom filter以及相关数学推导，最后给出了应用最佳实践。在文章最后提及基础布隆过滤器无法在保证false positive率的同时扩展存储，必须在使用前预估集合大小（n）。但是在很多情况下，集合大小无法预估，这就需要使用本篇介绍的布隆过滤器变体。

## 布隆过滤器变体

![布隆过滤器变体](https://raw.githubusercontent.com/oliverdding/imaw.io/main/variant_bloom_filter.drawio.svg)

布隆过滤器变体由以下两部分构成：

1. M位的位图：`bitmap`
2. k个相互独立的hash函数：`h1, h2, ..., hk`

其中，M位的位图被k等分，每个slice长度为m，即$m=\frac{M}{k}$。

与基础布隆过滤器不同的是，每个hash函数独享自己对应的slice（而不是全部位图）。

这种变体提高了健壮性，并且支持并发处理。

### 数学推导

对于某个slice，插入1个元素后，某一个位被置1、置0的概率为$\frac{1}{m}$、$1-\frac{1}{m}$

当插入n个元素后，某一位被置0、置1的概率是$(1-\frac{1}{m})^n$、$1-(1-\frac{1}{m})^n$

同样使用自然对数e的计算公式$$\lim_{x \to \infty}{(1-\frac{1}{x})^{-x}}=e$$

插入n个元素后某一位被置1的概率可以简化为$$p\approx{}1-e^{-\frac{n}{m}}$$

于是得到$$n\approx{}-mln(1-p)$$

又由公式$M=km$和$P=p^k$，我们推导出$m=M\frac{ln(p)}{ln(P)}$，因此有$$n\approx{}M\frac{ln(p)ln(1-p)}{-ln(P)}$$

对于给定的纳伪率$P$和位图大小M，当$p=\frac{1}{2}$时n取到最大值，此时能容纳最多的元素。$p$代表一个slice的饱和程度，我们得知slice半饱和时最好，对于$p=\frac{1}{2}$我们可以简化上面的公式为$$n\approx{}M\frac{(ln(2)^2)}{\lvert{}ln(P)\rvert{}}$$

P是给定的纳伪率，因此对于这个布隆过滤器变体而言，可以容纳的元素数量n是和位图大小M呈线性关系。

最后由$P=p^k$和$p=\frac{1}{2}$我们推导出$$k=log_{2}\frac{1}{P}$$

### 应用

#### 已知$n$和$P$

1. 根据公式$k=\lceil{}log_{2}\frac{1}{P}\rceil{}$计算k的值
2. 根据公式$m\approx{}\lceil{}\frac{n\lvert{}ln(P)\rvert{}}{kln^2(2)}\rceil{}$计算m的值

## 可扩展的布隆过滤器

本篇介绍的可扩展布隆过滤器（Scalable Bloom Filter, SBF）基于前文提及的布隆过滤器变体，有两个关键部分：

* SBF由一个或多个布隆过滤器组成。
* 后续的布隆过滤器的纳伪率成等比数列缩小，以保证整体纳伪率保持在一个数值内。

可扩展布隆过滤器同样存在两个操作：插入、查询。

当插入时，从过滤器列表最后一个过滤器插入新元素，并在“满了”时扩展过滤器列表。

但查询时，从前往后依次查询，每个过滤器都返回不存在时，则表明元素不存在，否则返回存在。

### 数学推导

SBF创建时只有一个布隆过滤器，$k_0$个slice，纳伪率为$P_0$。当这个过滤器满了，添加新的过滤器（$k_1$个slice，纳伪率为$P_1=P_{0}r$，且$0<r<1$）。

当SBF存在$l$个过滤器后，其纳伪率为$$P=1-\prod_{i=0}^{l-1}(1-P_{0}r^i)$$

由于有缩放公式$$1-\prod_{i}(1-P_i)\le{}\sum_{i}P_i$$

我们可以得到P的上限$$P\le{}\sum_{i=0}^{l-1}P_{0}r^{i}\le{}\lim_{l \to \infty}\sum_{i=0}^{l-1}P_{0}r^i$$

因此有$$P\le{}P_{0}\frac{1}{1-r}$$

每个过滤器的slice长度为$$k_{0}=log_{2}(P_{0}^{-1})$$，$$k_{i}=log_{2}(P_{i}^{-1})=k_{0}+ilog_{2}(r^{-1}) \tag{1}$$

为了保证每个k_i都是整数，我们自然会想让$r=\frac{1}{2}$，此时有$$k_i=k_0+i$$，意味着每添加一个过滤器都需要扩充一个slice。此时SBF的整体纳伪率为$$P\le{}2P_0=2^{1-k_0}$$

论文证明了如果$r\lt{}0.5$，尽管小量数据时使用空间大于$r=0.5$，随着空间增长空间使用反而更小。论文实验证明，r取0.8～0.9时为最佳。[^1]

事实上，后续添加的过滤器的纳伪率$P_i$只要低于整体纳伪率，则可保证整体纳伪率不增加。因此$k_i$的选取可以更加灵活，而不局限于(1)的公式。由于$P_i$和$k_i$成反比，只要$k_i$选取大于(1)的值即可保证$P_i$小。这里为了简化我们可以使用等比数列。假设k的取值为$P_0, P_{0}r, P_{0}r^2,...,P_{0}r^{l-1}$，此时过滤器可以存储的变量数$n_i$大约为$$n_i\approx{}m_{0}s^{i}ln(2)$$，有$l$个过滤器的SBF可以存储约$(ln2)m_{0}\sum_{i=0}^{l-1}s^i$个元素。

论文证明对于缓慢增长的SBF可以考虑设置$s=2$，对于快速增长的过滤器可以设置$s=4$。

### 应用

#### 已知$P$

1. 考虑使用$n=8192$构造初始布隆过滤器变体，计算获得$k_0$和m
2. 对于每个后续的$P_i=0.9P_{i-1}$
3. 对于每个后续的过滤器，$k_i=2k_{i-1}$或$k_i=4k_{i-1}$

## 参考

[^1]: Scalable Bloom Filters
